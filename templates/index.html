<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Glucose Simulation</title>
    <!-- Using specific compatible versions -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        .meal-entry {
            border: 1px solid #eee;
            padding: 10px;
            margin-bottom: 10px;
        }
        label {
            display: block;
            margin-top: 5px;
            margin-bottom: 2px;
        }
        input[type="number"] {
            width: 95%;
            padding: 8px;
            margin-bottom: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        #plot-container {
            width: 100%;
            max-width: 900px; /* Adjusted max-width */
            height: 450px;   /* Adjusted height */
            margin-top: 20px;
            border: 1px solid #ddd;
        }
        pre {
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            padding: 10px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 150px;
            overflow-y: auto;
        }
        hr {
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>Glucose Simulation Interface</h1>

    <h2>Meal Schedule</h2>
    <div id="meals-container">
        <!-- Initial meal entry -->
        <div class="meal-entry">
            <label for="meal-time-1">Meal Time 1 (minutes from start, e.g., 480 for 8 AM):</label>
            <input type="number" id="meal-time-1" class="meal-time" value="480" placeholder="e.g., 480">
            <label for="meal-carbs-1">Carbohydrates 1 (grams):</label>
            <input type="number" id="meal-carbs-1" class="meal-carbs" value="50" placeholder="e.g., 50">
        </div>
    </div>
    <button type="button" onclick="addMealEntry()">Add Another Meal</button>
    <hr>
    <button type="button" onclick="runSimulationAndPlot()">Run Simulation</button>

    <div id="plot-container">
        <canvas id="simulationChart"></canvas>
    </div>

    <div id="text-results-container" style="display:none; margin-top:20px;">
        <h2>Simulation Data (Raw)</h2>
        <h3>PPO Simulation:</h3>
        <pre id="ppo-results-json"></pre>
        <h3>PCPO Simulation:</h3>
        <pre id="pcpo-results-json"></pre>
    </div>

    <script>
        let mealCount = 1;

        function addMealEntry() {
            mealCount++;
            const mealsContainer = document.getElementById('meals-container');
            const newMealEntry = document.createElement('div');
            newMealEntry.classList.add('meal-entry');
            newMealEntry.innerHTML = `
                <label for="meal-time-${mealCount}">Meal Time ${mealCount} (minutes from start):</label>
                <input type="number" id="meal-time-${mealCount}" class="meal-time" placeholder="e.g., 720 for 12 PM">
                <label for="meal-carbs-${mealCount}">Carbohydrates ${mealCount} (grams):</label>
                <input type="number" id="meal-carbs-${mealCount}" class="meal-carbs" placeholder="e.g., 70">
            `;
            mealsContainer.appendChild(newMealEntry);
        }

        async function runSimulationAndPlot() {
            const mealEntries = document.querySelectorAll('.meal-entry');
            const meal_details_input = [];
            mealEntries.forEach(entry => {
                const timeInput = entry.querySelector('.meal-time');
                const carbsInput = entry.querySelector('.meal-carbs');
                if (timeInput.value && carbsInput.value) {
                    meal_details_input.push({
                        time_minutes: parseInt(timeInput.value),
                        carbs: parseFloat(carbsInput.value)
                    });
                }
            });

            const fetchPayload = { meals: meal_details_input };

            document.getElementById('text-results-container').style.display = 'none';
            const ppoJsonElement = document.getElementById('ppo-results-json');
            const pcpoJsonElement = document.getElementById('pcpo-results-json');
            ppoJsonElement.textContent = 'Running...';
            pcpoJsonElement.textContent = 'Running...';

            if (window.simulationChart instanceof Chart) {
                window.simulationChart.destroy();
            }

            try {
                const response = await fetch('/simulate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(fetchPayload)
                });
                
                const results = await response.json();

                if (!response.ok) {
                    throw new Error(results.error || `HTTP error! status: ${response.status}`);
                }
                
                if (results.error) {
                    alert("Error from server: " + results.error);
                    ppoJsonElement.textContent = `Error: ${results.error}`;
                    pcpoJsonElement.textContent = `Error: ${results.error}`;
                    return;
                }
                
                document.getElementById('text-results-container').style.display = 'block';
                ppoJsonElement.textContent = JSON.stringify(results.ppo_simulation, null, 2);
                pcpoJsonElement.textContent = JSON.stringify(results.pcpo_simulation, null, 2);
                
                plotResultsWithChartJS(results.ppo_simulation, results.pcpo_simulation, results.sim_sampling_rate);

            } catch (error) {
                console.error('Simulation or plotting error:', error);
                alert('Failed to run simulation: ' + error.message);
                ppoJsonElement.textContent = `Error: ${error.message}`;
                pcpoJsonElement.textContent = `Error: ${error.message}`;
            }
        }

        function plotResultsWithChartJS(ppoData, pcpoData, SIM_SAMPLING_RATE = 5) {
            let timeLabels = [];
            const ppoValid = ppoData && !ppoData.error && ppoData.cgm && ppoData.cgm.length > 0;
            const pcpoValid = pcpoData && !pcpoData.error && pcpoData.cgm && pcpoData.cgm.length > 0;

            let referenceData = null;
            if (ppoValid) referenceData = ppoData;
            else if (pcpoValid) referenceData = pcpoData;

            if (!referenceData) {
                console.error("No valid CGM data to plot from either PPO or PCPO.");
                if (window.simulationChart instanceof Chart) {
                    window.simulationChart.destroy();
                }
                const ctx = document.getElementById('simulationChart').getContext('2d');
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.font = "16px Arial";
                ctx.fillStyle = "red";
                ctx.textAlign = "center";
                ctx.fillText("No data to display or simulation error.", ctx.canvas.width/2, ctx.canvas.height/2);
                return;
            }
            
            timeLabels = referenceData.cgm.map((_, index) => (index * SIM_SAMPLING_RATE) / 60);
            const patientName = referenceData.patient_name || "N/A";

            const datasets = [];
            const yAxesConfig = {};
            
            if (ppoValid) {
                datasets.push({
                    label: 'PPO CGM (mg/dL)', data: ppoData.cgm, borderColor: '#1f77b4', 
                    yAxisID: 'yCGM', type: 'line', tension: 0.1, fill: false, pointRadius: 1.5
                });
                if (ppoData.insulin) {
                    datasets.push({
                        label: 'PPO Insulin (U/step)', data: ppoData.insulin, borderColor: 'rgba(31, 119, 180, 0.7)', 
                        borderDash: [5, 5], yAxisID: 'yInsulin', type: 'line', tension: 0.1, fill: false, pointRadius: 1.5
                    });
                }
            } else if (ppoData && ppoData.error) {
                 console.warn("PPO Simulation Error:", ppoData.error);
            }

            if (pcpoValid) {
                 datasets.push({
                    label: 'PCPO CGM (mg/dL)', data: pcpoData.cgm, borderColor: '#ff7f0e', 
                    yAxisID: 'yCGM', type: 'line', tension: 0.1, fill: false, pointRadius: 1.5
                });
                if (pcpoData.insulin) {
                     datasets.push({
                        label: 'PCPO Insulin (U/step)', data: pcpoData.insulin, borderColor: 'rgba(255, 127, 14, 0.7)', 
                        borderDash: [5, 5], yAxisID: 'yInsulin', type: 'line', tension: 0.1, fill: false, pointRadius: 1.5
                    });
                }
            } else if (pcpoData && pcpoData.error) {
                console.warn("PCPO Simulation Error:", pcpoData.error);
            }

            yAxesConfig.yCGM = {
                type: 'linear', display: true, position: 'left',
                title: { display: true, text: 'CGM (mg/dL)', font: { weight: 'bold'} },
                suggestedMin: 0, suggestedMax: 400, // Or make dynamic
                ticks: { color: '#000080' }
            };
            yAxesConfig.yInsulin = {
                type: 'linear', display: true, position: 'right',
                title: { display: true, text: 'Insulin (U/step)', font: { weight: 'bold'} },
                grid: { drawOnChartArea: false }, suggestedMin: 0,
                ticks: { color: 'mediumseagreen' }
            };
            
            let commonMealDataArray = null;
            if (ppoValid && ppoData.meal) commonMealDataArray = ppoData.meal;
            else if (pcpoValid && pcpoData.meal) commonMealDataArray = pcpoData.meal;

            if (commonMealDataArray) {
                const mealAmountsForChart = commonMealDataArray.map(m => m > 0 ? m : NaN);
                const maxMeal = Math.max(...commonMealDataArray.filter(m => m > 0), 0);

                datasets.push({
                    label: 'Meals CHO (g)', data: mealAmountsForChart, backgroundColor: 'rgba(128, 0, 0, 0.6)', 
                    yAxisID: 'yMeals', type: 'bar', barPercentage: 0.3, categoryPercentage: 0.5
                });
                yAxesConfig.yMeals = {
                    type: 'linear', display: true, position: 'right',
                    title: { display: true, text: 'CHO (g)', font: { weight: 'bold'} },
                    grid: { drawOnChartArea: false },
                    offset: true, 
                    suggestedMin: 0,
                    suggestedMax: maxMeal > 0 ? maxMeal * 1.2 : 10,
                    ticks: { color: '#800000' }
                };
            }
            
            const chartData = {
                labels: timeLabels,
                datasets: datasets
            };

            if (window.simulationChart instanceof Chart) {
                window.simulationChart.destroy();
            }

            const ctx = document.getElementById('simulationChart').getContext('2d');
            window.simulationChart = new Chart(ctx, {
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false, axis: 'x' },
                    plugins: {
                        title: { display: true, text: `Simulation Results for Patient ID ${patientName}`, font: { size: 16 } },
                        legend: { position: 'top', labels: { usePointStyle: true } },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed.y !== null) label += context.parsed.y.toFixed(2);
                                    if (context.dataset.type === 'bar' && isNaN(context.parsed.y)) return null; 
                                    return label;
                                }
                            }
                        },
                        annotation: { 
                            annotations: {
                                line70: { type: 'line', yScaleID: 'yCGM', value: 70, borderColor: 'red', borderWidth: 1.5, borderDash: [5, 5], label: { content: 'Hypo (<70)', enabled: true, position: "start", font: {style: 'italic'}}},
                                line180: { type: 'line', yScaleID: 'yCGM', value: 180, borderColor: 'darkorange', borderWidth: 1.5, borderDash: [5, 5], label: { content: 'Hyper (>180)', enabled: true, position: "start", font: {style: 'italic'}}},
                                line250: { type: 'line', yScaleID: 'yCGM', value: 250, borderColor: 'maroon', borderWidth: 1.5, borderDash: [2, 2], label: { content: 'Severe Hyper (>250)', enabled: true, position: "start", font: {style: 'italic'}}},
                                boxNormo: { type: 'box', yScaleID: 'yCGM', yMin: 70, yMax: 180, backgroundColor: 'rgba(75, 192, 75, 0.1)', borderColor: 'transparent' }
                            }
                        }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: `Time (hours) - Each step = ${SIM_SAMPLING_RATE} min`, font: { weight: 'bold'} },
                            grid: { display: false }
                        },
                        ...yAxesConfig
                    }
                }
            });
        }
    </script>
</body>
</html>